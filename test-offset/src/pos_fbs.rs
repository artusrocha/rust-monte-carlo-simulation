// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod pos {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    pub enum PosOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Pos<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Pos<'a> {
        type Inner = Pos<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Pos<'a> {
        pub const VT_DST: flatbuffers::VOffsetT = 4;
        pub const VT_ACC_ID: flatbuffers::VOffsetT = 6;
        pub const VT_INS_ID: flatbuffers::VOffsetT = 8;
        pub const VT_GRP: flatbuffers::VOffsetT = 10;
        pub const VT_GRPV: flatbuffers::VOffsetT = 12;
        pub const VT_QTY: flatbuffers::VOffsetT = 14;
        pub const VT_FACTOR: flatbuffers::VOffsetT = 16;
        pub const VT_RATIO: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Pos { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PosArgs,
        ) -> flatbuffers::WIPOffset<Pos<'bldr>> {
            let mut builder = PosBuilder::new(_fbb);
            builder.add_ratio(args.ratio);
            builder.add_factor(args.factor);
            builder.add_qty(args.qty);
            builder.add_ins_id(args.ins_id);
            builder.add_acc_id(args.acc_id);
            builder.add_dst(args.dst);
            builder.add_grp(args.grp);
            builder.add_grpv(args.grpv);
            builder.finish()
        }

        #[inline]
        pub fn dst(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Pos::VT_DST, Some(0)).unwrap() }
        }
        #[inline]
        pub fn acc_id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Pos::VT_ACC_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn ins_id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Pos::VT_INS_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn grp(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u16>(Pos::VT_GRP, Some(0)).unwrap() }
        }
        #[inline]
        pub fn grpv(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Pos::VT_GRPV, Some(0)).unwrap() }
        }
        #[inline]
        pub fn qty(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f32>(Pos::VT_QTY, Some(0.0)).unwrap() }
        }
        #[inline]
        pub fn factor(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f32>(Pos::VT_FACTOR, Some(0.0)).unwrap() }
        }
        #[inline]
        pub fn ratio(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f32>(Pos::VT_RATIO, Some(0.0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Pos<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("dst", Self::VT_DST, false)?
                .visit_field::<u32>("acc_id", Self::VT_ACC_ID, false)?
                .visit_field::<u32>("ins_id", Self::VT_INS_ID, false)?
                .visit_field::<u16>("grp", Self::VT_GRP, false)?
                .visit_field::<u8>("grpv", Self::VT_GRPV, false)?
                .visit_field::<f32>("qty", Self::VT_QTY, false)?
                .visit_field::<f32>("factor", Self::VT_FACTOR, false)?
                .visit_field::<f32>("ratio", Self::VT_RATIO, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PosArgs {
        pub dst: u32,
        pub acc_id: u32,
        pub ins_id: u32,
        pub grp: u16,
        pub grpv: u8,
        pub qty: f32,
        pub factor: f32,
        pub ratio: f32,
    }
    impl<'a> Default for PosArgs {
        #[inline]
        fn default() -> Self {
            PosArgs {
                dst: 0,
                acc_id: 0,
                ins_id: 0,
                grp: 0,
                grpv: 0,
                qty: 0.0,
                factor: 0.0,
                ratio: 0.0,
            }
        }
    }

    pub struct PosBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PosBuilder<'a, 'b> {
        #[inline]
        pub fn add_dst(&mut self, dst: u32) {
            self.fbb_.push_slot::<u32>(Pos::VT_DST, dst, 0);
        }
        #[inline]
        pub fn add_acc_id(&mut self, acc_id: u32) {
            self.fbb_.push_slot::<u32>(Pos::VT_ACC_ID, acc_id, 0);
        }
        #[inline]
        pub fn add_ins_id(&mut self, ins_id: u32) {
            self.fbb_.push_slot::<u32>(Pos::VT_INS_ID, ins_id, 0);
        }
        #[inline]
        pub fn add_grp(&mut self, grp: u16) {
            self.fbb_.push_slot::<u16>(Pos::VT_GRP, grp, 0);
        }
        #[inline]
        pub fn add_grpv(&mut self, grpv: u8) {
            self.fbb_.push_slot::<u8>(Pos::VT_GRPV, grpv, 0);
        }
        #[inline]
        pub fn add_qty(&mut self, qty: f32) {
            self.fbb_.push_slot::<f32>(Pos::VT_QTY, qty, 0.0);
        }
        #[inline]
        pub fn add_factor(&mut self, factor: f32) {
            self.fbb_.push_slot::<f32>(Pos::VT_FACTOR, factor, 0.0);
        }
        #[inline]
        pub fn add_ratio(&mut self, ratio: f32) {
            self.fbb_.push_slot::<f32>(Pos::VT_RATIO, ratio, 0.0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PosBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PosBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Pos<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Pos<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Pos");
            ds.field("dst", &self.dst());
            ds.field("acc_id", &self.acc_id());
            ds.field("ins_id", &self.ins_id());
            ds.field("grp", &self.grp());
            ds.field("grpv", &self.grpv());
            ds.field("qty", &self.qty());
            ds.field("factor", &self.factor());
            ds.field("ratio", &self.ratio());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `Pos`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_pos_unchecked`.
    pub fn root_as_pos(buf: &[u8]) -> Result<Pos, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Pos>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Pos` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_pos_unchecked`.
    pub fn size_prefixed_root_as_pos(buf: &[u8]) -> Result<Pos, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Pos>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Pos` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_pos_unchecked`.
    pub fn root_as_pos_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Pos<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Pos<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Pos` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_pos_unchecked`.
    pub fn size_prefixed_root_as_pos_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Pos<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Pos<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Pos and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Pos`.
    pub unsafe fn root_as_pos_unchecked(buf: &[u8]) -> Pos {
        flatbuffers::root_unchecked::<Pos>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Pos and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Pos`.
    pub unsafe fn size_prefixed_root_as_pos_unchecked(buf: &[u8]) -> Pos {
        flatbuffers::size_prefixed_root_unchecked::<Pos>(buf)
    }
    #[inline]
    pub fn finish_pos_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Pos<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_pos_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Pos<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod pos
